---
layout: post
title:  "Fib vs Fib"
author: Rauan
date:   2024-01-21
tags: algoritmo python 
---

### Nervouser na entrevista

Um tempo atr√°s, durante a etapa t√©cnica de uma entrevista de emprego, tive que resolver alguns probleminhas em call
com o supervisor do setor. Coisa simples: √°rvore bin√°ria, pal√≠ndromo, etc., por√©m, j√° um tanto _nervouser_, 
me atrapalhei justamente no problema mais f√°cil, implementar <a href="https://pt.wikipedia.org/wiki/Sequ%C3%AAncia_de_Fibonacci" target = "_blank">Fibonacci</a>.

N√£o lembro exatamente, mas a quest√£o era alguma coisa assim:

`Implemente um programa que escreva a sequ√™ncia de Fibonacci at√© um determinado n√∫mero.`
* <small> al√©m disso, a lista deveria ser formatada assim -> "0,1,1,2,3,5..."</small>

Perceba como esse problema √© diferente de:

`Implemente um programa que escreva um determinado termo da sequ√™ncia de Fibonacci`

O primeiro problema pede uma lista de termos da sequ√™ncia de Fibonacci at√© um n√∫mero m√°ximo N.

O segundo problema pede o valor do termo N da sequ√™ncia de Fibonacci.


### ¬øEst√°s en duda? No se adelante

Ao inv√©s de parar um tempo pra refletir sobre o que o problema pedia, um pouco encabulado de parecer inapto a
resolver um problema (que eu julgava) trivial, come√ßei a escrever.

Rapidamente implementei algo mais ou menos assim:

```python
from functools import lru_cache

@lru_cache()
def fib(nth_fib_number):
    if nth_fib_number < 1:
        return None
    if nth_fib_number in [1, 2]:
        return 1
    else:
        return fib(nth_fib_number-1) + fib(nth_fib_number-2)

if __name__ == '__main__':
    N = 100
    print(fib(N))
```

Percebendo que esse programa calculava e _printava_ o termo N da sequ√™ncia e n√£o a sequ√™ncia at√© o termo N, tentei remendar:

```python
from functools import lru_cache

@lru_cache()
def fib(nth_fib_number):
    ...

if __name__ == '__main__':
    N = 100
    lista = []
    for i in range(1, N):
        termo = fib(i)
        if termo > N:
            break
        else:
            lista.append(str(termo))
    print(','.join(lista))
```

Ok, funciona. Mas...

* Como n√£o sabia at√© qual termo calcular para chegar no m√°ximo N, usei o pr√≥prio N como range, pois `fib(N) >= N`.
Por√©m tive que usar uma condicional e um `break` para parar a itera√ß√£o <small>(q horror)</small>.
* Apesar do <a href="https://www.google.com/search?q=memoization" target="_blank">`@lru_cache`</a>, esse c√≥digo n√£o
√© eficiente pois cada itera√ß√£o recalcula os termos j√° calculados na itera√ß√£o anterior.

### Big solu√ßo elegante

Depois da entrevista, percebendo que a minha solu√ß√£o n√£o era boa o suficiente, decidi buscar como resolver o problema de uma
maneira mais eficiente. Encontrei o seguinte c√≥digo:

```python
1  def fib(max):
2      a, b = 0, 1
3      while a < max:
4          yield str(a)
5          a, b = b, a + b
6  
7  if __name__ == '__main__':
8      N = 100
9      print(','.join(list(fib(N))))
```

O c√≥digo acima √© bem mais simples, elegante e n√£o recalcula valores desnecessariamente. 

* A fun√ß√£o `fib` retorna um objeto gerador, e o corpo da fun√ß√£o define sua l√≥gica de funcionamento.
* A cada loop (`while a < max`), a fun√ß√£o retorna (ou gera) um novo componente dessa sequ√™ncia, utilizando a _keyword_ `yield`
* A linha _5_ especifica a l√≥gica por tr√°s da sequ√™ncia de Fibonacci: o pr√≥ximo n√∫mero da sequ√™ncia √© a soma dos dois anteriores.

### Li√ß√µes do dia

* Reler a quest√£o √© √∫til
* Yield √© divertido

at√© maix
üòä